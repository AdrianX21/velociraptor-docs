<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Welcome on Velociraptor - Digging deeper!</title><link>https://docs.velociraptor.app/</link><description>Recent content in Welcome on Velociraptor - Digging deeper!</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 12 Jun 2021 07:11:04 +0000</lastBuildDate><atom:link href="https://docs.velociraptor.app/index.xml" rel="self" type="application/rss+xml"/><item><title>Browsing around the filesystem.</title><link>https://docs.velociraptor.app/blog/html/2018/08/10/browsing_around_the_filesystem.html</link><pubDate>Fri, 10 Aug 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/08/10/browsing_around_the_filesystem.html</guid><description>The Virtual File System Like GRR, Velociraptor also maintains a virtual file system view (VFS) of the client's filesystem. GRR's VFS view is generated by adding a row for each file into the database. In order to refresh the view of a certain directory, GRR issues a ListDirectory request and updates the database by storing each newly discovered file in its own row.
Velociraptor models the client's VFS as a per-directory VQL query.</description></item><item><title>Parsing binary files</title><link>https://docs.velociraptor.app/blog/2021/2021-01-19-parsing-binary-files-d31114a41f14/</link><pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/blog/2021/2021-01-19-parsing-binary-files-d31114a41f14/</guid><description>During the course of our DFIR work, we typically need to extract some information from endpoints from various files and registry keys on the system. Sometimes it is possible to extract the needed information using text processing tools â€” such as a regular expression applied on a configuration file.
In many cases however, the information we need is encoded inside a binary file. A large part of DFIR analysis involves parsing binary structures from files, registry keys and even event logs.</description></item><item><title>Recovering deleted NTFS Files with Velociraptor</title><link>https://docs.velociraptor.app/blog/2019/2019-11-15_recovering-deleted-ntfs-files-with-velociraptor-1fcf09855311/</link><pubDate>Fri, 15 Nov 2019 00:38:44 +0000</pubDate><guid>https://docs.velociraptor.app/blog/2019/2019-11-15_recovering-deleted-ntfs-files-with-velociraptor-1fcf09855311/</guid><description>By Mike Cohen On a recent engagement we responded to an intrusion where the attacker has added a new scheduled task to the Windows Task Scheduler directory (%systemroot%\System32\Task) some time ago. This is a common TTP for achieving persistence (See Mitre Att&amp;amp;ck). Unfortunately the actual task file was later removed and event logs were cycled past the time of interest.
In that case we were able to use Velociraptor to employ some deep forensic techniques and with a bit of luck were able to recover the deleted task file.</description></item><item><title>The Velociraptor API and FUSE</title><link>https://docs.velociraptor.app/blog/html/2019/08/28/the_velociraptor_api/</link><pubDate>Mon, 26 Aug 2019 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2019/08/28/the_velociraptor_api/</guid><description>The Velociraptor GUI is very useful, but for the power user, the Velociraptor API provides a powerful mechanism to integrate and automate. We previously discussed how the Velociraptor API can be used by external programs. This post explore a sample program that uses the API and presents a client&amp;rsquo;s VFS as a FUSE directory.
This allows us to navigate the remote end point&amp;rsquo;s file system as if it was mounted locally - we can list directories or fetch files, or even open remote files using third party programs.</description></item><item><title>Agentless hunting with Velociraptor</title><link>https://docs.velociraptor.app/blog/html/2019/03/02/agentless_hunting_with_velociraptor.html</link><pubDate>Sat, 02 Mar 2019 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2019/03/02/agentless_hunting_with_velociraptor.html</guid><description>There has been a lot of interest lately in Agentless hunting especially using PowerShell. There are many reasons why Agentless hunting is appealing - there are already a ton of endpoint agents and yet another one may not be welcome. Somtimes we need to deploy endpoint agents as part of a DFIR engagement and we may not want to permanently install yet another agent on end points.
This blog post explores an agentless deployment scenario, where we do not want to install Velociraptor permanently on the end point, but rather push it to end points temporarily to collect specific artifacts.</description></item><item><title>Alerting on event patterns</title><link>https://docs.velociraptor.app/blog/html/2019/02/14/alerting_on_event_patterns.html</link><pubDate>Thu, 14 Feb 2019 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2019/02/14/alerting_on_event_patterns.html</guid><description>We have shown in earlier posts how Velociraptor uses VQL to define event queries that can detect specific conditions. These conditions can be used to create alerts and escalation actions.
One of the most useful types of alerts is detecting a pattern of activity. For example we can detect failed and successful login attempts seperately, but it is the specific pattern of events (say 5 failed login attempts followed by a successful one) that is interesting from a detection point of view.</description></item><item><title>Velociraptor Performance</title><link>https://docs.velociraptor.app/blog/html/2019/02/10/velociraptor_performance.html</link><pubDate>Sun, 10 Feb 2019 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2019/02/10/velociraptor_performance.html</guid><description>We are often asked how many resources does a Velociraptor deployment use? How should one spec a machine for a Velociraptor deployment?
We have previously said that one of the reasons we developed Velociraptor was to improve on the performance of GRR which was not scalable for our use case.
We've been working with the team at Klein &amp;amp; Co. on several intrusions over the past several months, which are providing valuable opportunities to deploy and test Velociraptor in a range of real world investigation scenarios.</description></item><item><title>The Velociraptor Python API</title><link>https://docs.velociraptor.app/blog/html/2019/02/09/velociraptor_python_api.html</link><pubDate>Sat, 09 Feb 2019 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2019/02/09/velociraptor_python_api.html</guid><description>Velociraptor is very good at collecting artifacts from endpoints. However, in modern DFIR work, the actual collection is only the first step of a much more involved process. Typically we want to post process data using more advanced data mining tools (such as data stacking). Velociraptor usually is only a part of a wider solution which might include a SIEM and SOC integration.
In order to facilitate interoperability with other tools, Velociraptor now offers an external API.</description></item><item><title>Velociraptor's client communications</title><link>https://docs.velociraptor.app/blog/html/2018/09/03/velociraptor_s_client_communications.html</link><pubDate>Sat, 09 Feb 2019 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/09/03/velociraptor_s_client_communications.html</guid><description>How does the GRR client communicate? The GRR client protocol is depicted below.
image Due to network realities such as NAT, firewalls etc, it is not possible to directly connect to the client, so GRR relies on the client connecting to the server in order to communicate with it.
The GRR client makes periodic POST requests to the server to both send replies and receive new instructions. Since POST requests are very short lived (most client polls carry no data) the client has to repeat the polls periodically.</description></item><item><title>Deploying Velociraptor with OAuth SSO</title><link>https://docs.velociraptor.app/blog/html/2018/12/23/deploying_velociraptor_with_oauth_sso.html</link><pubDate>Sun, 23 Dec 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/12/23/deploying_velociraptor_with_oauth_sso.html</guid><description>In the previous post we saw how to set up Velociraptor's GUI over SSL. This is great, but we still need to create users and assign them passwords manually. The trouble with user account management is that we can not enforce 2 factor authentication, or any password policies or any of the usual enterprise requirements for user account management. It is also difficult for users to remember yet another password for a separate system, and so might make the password easily guessable.</description></item><item><title>Configuring Velociraptor for SSL</title><link>https://docs.velociraptor.app/blog/html/2018/12/22/configuring_velociraptor_for_ssl.html</link><pubDate>Sat, 22 Dec 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/12/22/configuring_velociraptor_for_ssl.html</guid><description>We have previously seen how to deploy a new Velociraptor server. For a simple deployment we can have Velociraptor server and clients provisioned in minutes.
Usually we deploy a specific Velociraptor deployment on our DFIR engagements. We use cloud resources to provision the server and have the clients connect to this cloud VM. A proper secure deployment of Velociraptor will use SSL for securing both client communication and protecting the web GUI.</description></item><item><title>Velociraptor Interactive Shell</title><link>https://docs.velociraptor.app/blog/html/2018/12/11/velociraptor_interactive_shell.html</link><pubDate>Tue, 11 Dec 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/12/11/velociraptor_interactive_shell.html</guid><description>One of the interesting new features in the latest release of Velociraptor is an interactive shell. One can interact with the end point over the standard Velociraptor communication mechanism - an encrypted and authenticated channel.
This feature is implemented by utilizing the Velociraptor event monitoring, server side VQL queries. This post explores how these components come together to deliver a responsive, interactive workflow.
Endpoint shell access Although we generally try to avoid it, sometimes the easiest way to extract certain information is to run a command and parse its output.</description></item><item><title>Server side VQL queries and Escalation Events</title><link>https://docs.velociraptor.app/blog/html/2018/12/10/server_side_vql_queries_and_events.html</link><pubDate>Mon, 10 Dec 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/12/10/server_side_vql_queries_and_events.html</guid><description>Previously we have seen how Velociraptor collects information from end points using Velociraptor artifacts. These artifacts encapsulate user created queries using the Velociraptor Query Language (VQL). The power of VQL is that it provides for a very flexible way of specifying exactly what should be collected from the client and how - without needing to modify client code or deploy new clients!
This is not the whole story though! It is also possible to run VQL queries on the server side!</description></item><item><title>More on client event collection</title><link>https://docs.velociraptor.app/blog/html/2018/12/09/more_on_client_event_collection.html</link><pubDate>Sun, 09 Dec 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/12/09/more_on_client_event_collection.html</guid><description>Periodic Event queries The simplest kind of events are periodically generated events. These are created using the clock() VQL plugin. This is a simple event plugin which just emits a new row periodically.
$ velociraptor query &amp;quot;select Unix from clock(period=5)&amp;quot; --max_wait 1 [ { &amp;quot;Unix&amp;quot;: 1544339715 } ][ { &amp;quot;Unix&amp;quot;: 1544339720 } ]^C The query will never terminate, instead the clock() plugin will emit a new timestamp every 5 seconds. Note the --max_wait flag which tells Velociraptor to wait at least for 1 second in order to batch rows before reporting them.</description></item><item><title>Velociraptor training at NZITF</title><link>https://docs.velociraptor.app/blog/html/2018/11/13/velociraptor_training_at_nzitf.html</link><pubDate>Tue, 13 Nov 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/11/13/velociraptor_training_at_nzitf.html</guid><description>Velociraptor training at NZITF We are very excited to run this full day training workshop at the New Zealand Internet Engineering Task Force (NZITF) conference.
The training material can be downloaded here &amp;quot;Velociraptor NZITF training&amp;quot;.</description></item><item><title>Event Queries and Endpoint Monitoring</title><link>https://docs.velociraptor.app/blog/html/2018/11/09/event_queries_and_endpoint_monitoring.html</link><pubDate>Fri, 09 Nov 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/11/09/event_queries_and_endpoint_monitoring.html</guid><description>Why monitor endpoint events? Recording end point event information on the server gives a bunch of advantages. For one, the server keeps a record of historical events, which makes going back to search for these easy as part of an incident response activity.
For example, Velociraptor can keep a running log of process execution events for all clients, on the server. If a particular executable is suspected to be malicious, we can now go back and search for the execution of that process in the past on the infected machine (for establishing the time of infection), as well as search the entire deployment base for the same binary execution to be able identify lateral movement and wider compromises.</description></item><item><title>Velorciraptor's filesystem's accessors</title><link>https://docs.velociraptor.app/blog/html/2018/09/30/velorciraptor_s_filesystem_s_accessors.html</link><pubDate>Sun, 30 Sep 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/09/30/velorciraptor_s_filesystem_s_accessors.html</guid><description>In addition, Velociraptor can now also read Volume Shadow Copy snapshots. The gives a kind of time-machine ability to allow the investigator to look through the drive content at a previous point in the past.
This blog post introduces the new features and describe how Velociraptor's filesystem accessors work to provide data from multiple sources to VQL queries.
We have previously seen that Velociraptor can list and download files from the client's filesystem, as well as registry keys and values.</description></item><item><title>Detecting powershell persistence with Velociraptor and Yara</title><link>https://docs.velociraptor.app/blog/html/2018/09/29/detecting_powershell_persistence_with_velociraptor_and_yara.html</link><pubDate>Sat, 29 Sep 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/09/29/detecting_powershell_persistence_with_velociraptor_and_yara.html</guid><description>::: {.admonition} Update
As of the latest release of Velociraptor we have raw registry parsing which can also be done via raw NTFS to get around file locking. It is no longer necessary to run yara scans and parse with regripper as shown here. :::
I was watching the SANS DFIR Summit 2018 videos on youtube and came across Mari DeGrazia's talk titled &amp;quot;Finding and Decoding Malicious Powershell Scripts&amp;quot;. This is an excellent talk and it really contains a wealth of information.</description></item><item><title>Velociraptor walk through and demo</title><link>https://docs.velociraptor.app/blog/html/2018/09/03/velociraptor_walk_through_and_demo.html</link><pubDate>Mon, 03 Sep 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/09/03/velociraptor_walk_through_and_demo.html</guid><description>I just uploaded a screencast of the latest Velociraptor - check it out and play with it, and please provide feedback at velociraptor-discuss@googlegroups.com</description></item><item><title>Velociraptor Artifacts</title><link>https://docs.velociraptor.app/blog/html/2018/08/20/velociraptor_artifacts.html</link><pubDate>Mon, 20 Aug 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/08/20/velociraptor_artifacts.html</guid><description>First a bit of history. When we first started writing endpoint monitoring tools (With GRR then Rekall Agent) we implemented the ability to collect files, registry keys and other data. If an analyst wanted to collect, say the chrome extensions, they would need to know where chrome extensions typically reside ( %homedir%/.config/google-chrome/Extensions/**) and enter that in each time.
We soon realized this was error prone and required too much mental overhead for analysts to constantly remember these details.</description></item><item><title>Design differences between Velociraptor and GRR</title><link>https://docs.velociraptor.app/blog/html/2018/08/10/design_differences_between_velociraptor_and_grr.html</link><pubDate>Fri, 10 Aug 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/08/10/design_differences_between_velociraptor_and_grr.html</guid><description>Velociraptor Clients run full VQL queries GRR's design started off with the assumption that the client should be minimalist and only support a few simple primitives (such as ListDirectory, ListProcesses etc). The intention was that most of the processing would be executed on the server inside a &amp;quot;Flow&amp;quot;. The main motivation for this design choice was the observation that it is difficult to upgrade the client in practice, and so with a minimal client, it would be possible to develop more sophisticated Flows, server side, without needing to update the clients.</description></item><item><title>Files, files everything is just a file!</title><link>https://docs.velociraptor.app/blog/html/2018/02/09/files_files_everything_is_just_a_file.html</link><pubDate>Fri, 10 Aug 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/02/09/files_files_everything_is_just_a_file.html</guid><description>GRR's original design abstracted the data storage to a simple key/value store originally based around Bigtable. For open source deployments various key value stores were used starting from MongoDB, to SQLite and finally MySQL. Although the original idea was to use a simple key/value implementation, due to locking requirements the data store implementation became very complex.
As Velociraptor introduced a major redesign of the underlying data store architecture, we are now able to relax our demands of the datastore and use a true key/value model (since we have no requirements for locking and synchronization).</description></item><item><title>Hunting - What Velociraptors do best!</title><link>https://docs.velociraptor.app/blog/html/2018/08/10/hunting_what_velociraptors_do_best.html</link><pubDate>Fri, 10 Aug 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/08/10/hunting_what_velociraptors_do_best.html</guid><description>Velociraptor has completely redesigned the way that hunts are implemented in order to avoid database locking and increase hunt processing efficiency.
Now we hunt like this:
image {.align-center}
How are hunts scheduled? GRR allows hunts to be scheduled by a few client properties such as OS type, label, users etc. This works because GRR has an extensive data model of endpoint properties. However, this requires that the data model be refreshed periodically to be kept accurate.</description></item><item><title>Interrogation - Make the endpoint tell us what it knows!</title><link>https://docs.velociraptor.app/blog/html/2018/08/10/interrogation_make_the_endpoint_tell_us_what_it_knows.html</link><pubDate>Fri, 10 Aug 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/08/10/interrogation_make_the_endpoint_tell_us_what_it_knows.html</guid><description>When writing Velociraptor we decided to keep things very simple - we did away with a lot of the information gathered during interrogate in favor of a much simpler data model.
Data Modelling - The Interrogate Flow GRR maintains an elaborate model of client data. For example, GRR collects and maintains a list of clients' network interfaces, users, user's home directory etc. This information is maintained in elaborate protobufs and stored in the database in many rows.</description></item><item><title>Velocidex Query Language (VQL)</title><link>https://docs.velociraptor.app/blog/html/2018/08/10/the_velocidex_query_language.html</link><pubDate>Fri, 10 Aug 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/08/10/the_velocidex_query_language.html</guid><description>VQL Overview VQL is only loosely based around SQL in the sense that the general statement structure is similar. However, VQL is a very simple dialect. Like SQL, a VQL query produces a table of results with specific columns and multiple rows. Unlike SQL, the data inside each cell is not limited to simple primitive types (like string, integer etc). In fact any JSON serializable object can be generated in a table's cell.</description></item><item><title>Introducing Velociraptor</title><link>https://docs.velociraptor.app/blog/html/2018/08/10/introducing_velociraptor.html</link><pubDate>Fri, 09 Feb 2018 04:10:06 +0000</pubDate><guid>https://docs.velociraptor.app/blog/html/2018/08/10/introducing_velociraptor.html</guid><description>Hunting and responding like a raptor! At Velocidex we have been running open source endpoint monitoring tools for our clients in order to detect and respond to incidents. One of our favorite tools is GRR, developed by Google internally and then released as open source. GRR is a very powerful tool, with a polished UI and good documentation.
Unfortunately the open source version released by Google suffers from some shortcomings and so we have decided to develop a new project, built on the shoulders of giants called Velociraptor.</description></item><item><title>Binparsergen</title><link>https://docs.velociraptor.app/golang/binparsergen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/golang/binparsergen/</guid><description/></item><item><title>Custom.Label.User</title><link>https://docs.velociraptor.app/exchange/artifacts/pages/custom.label.user/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/exchange/artifacts/pages/custom.label.user/</guid><description>This artifact watches for new client enrolments and automatically label the client with the required label if the user exists.
This artifact can be the starting point for automatically labeling a machine based on any other property - just change the artifact to watch and the result filter.
#server #event #labels
name:Custom.Label.Userdescription:|This artifact watches for new client enrolments and automatically label the client with the required label if the user exists.</description></item><item><title>Custom.Server.Slack.Clients.Enrolled</title><link>https://docs.velociraptor.app/exchange/artifacts/pages/custom.server.slack.clients.enrolled/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/exchange/artifacts/pages/custom.server.slack.clients.enrolled/</guid><description>Send a message to slack when clients become enrolled.
This artifact triggers when a client is interrogated within 60 seconds of it being seen for the first time.
name:Custom.Server.Slack.Clients.Enrolleddescription:|Send a message to slack when clients become enrolled. This artifact triggers when a client is interrogated within 60 seconds of it being seen for the first time.type:SERVER_EVENTparameters:- name:FirstSeenDelaydefault:&amp;#34;60&amp;#34;type:intdescription:|The time between first_seen_time and Generic.Client.Info collection.- name:SlackTokendescription:|The token URL obtained from Slack. Leave blank to use server metadata.</description></item><item><title>Custom.Windows.ETW.DetectProcessSpoofing</title><link>https://docs.velociraptor.app/exchange/artifacts/pages/custom.windows.etw.detectprocessspoofing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/exchange/artifacts/pages/custom.windows.etw.detectprocessspoofing/</guid><description>Detects Process parent spoofing such as SelectMyParent.exe
name:Custom.Windows.ETW.DetectProcessSpoofingdescription:|Detects Process parent spoofing such as SelectMyParent.exereference:- https://blog.f-secure.com/detecting-parent-pid-spoofing/type:CLIENT_EVENTsources:- precondition:SELECT OS From info() where OS = &amp;#39;windows&amp;#39;query:|LET RecentProcesses = SELECT * FROM fifo(query={ SELECT * FROM chain( -- Fill the fifo with the existing process listing at the start of the query. a={ SELECT CreateTime, Name, Pid FROM pslist()}, b={ SELECT System.TimeStamp AS CreateTime, EventData.ImageName AS Name, int(int=EventData.ProcessID) AS Pid FROM watch_etw(guid=&amp;#34;{22fb2cd6-0e7b-422b-a0c7-2fad1fd0e716}&amp;#34;, any=0x10) WHERE System.</description></item><item><title>Discord</title><link>https://docs.velociraptor.app/discord/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/discord/</guid><description/></item><item><title>EVTX</title><link>https://docs.velociraptor.app/golang/evtx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/golang/evtx/</guid><description/></item><item><title>Go ESE Parser</title><link>https://docs.velociraptor.app/golang/go-ese/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/golang/go-ese/</guid><description/></item><item><title>Go YARA</title><link>https://docs.velociraptor.app/golang/go-yara/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/golang/go-yara/</guid><description/></item><item><title>Go-NTFS</title><link>https://docs.velociraptor.app/golang/go-ntfs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/golang/go-ntfs/</guid><description/></item><item><title>Go-PE</title><link>https://docs.velociraptor.app/golang/go-pe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/golang/go-pe/</guid><description/></item><item><title>Go-Prefetch</title><link>https://docs.velociraptor.app/golang/go-prefetch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/golang/go-prefetch/</guid><description/></item><item><title>HashRunKeys</title><link>https://docs.velociraptor.app/exchange/artifacts/pages/hash_run_keys/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/exchange/artifacts/pages/hash_run_keys/</guid><description>Iterate over all the run keys and locate their binary then hash it.
#windows #registry #detection
name:HashRunKeysdescription:|Iterate over all the run keys and locate their binary then hash it. #windows #registry #detectionparameters:- name:runKeysdefault:|HKEY_USERS\*\Software\Microsoft\Windows\CurrentVersion\Run\*- name:pathRegextype:hidden# Pick the first part - either quoted or not.default:&amp;gt;-(^&amp;#34;(?P&amp;lt;quoted_path&amp;gt;[^&amp;#34;]+)&amp;#34;|(?P&amp;lt;unquoted_path&amp;gt;^[^ ]+))sources:- precondition:SELECT OS From info() where OS = &amp;#39;windows&amp;#39;queries:- LET paths = SELECT FullPath,Name, Data.value AS Value,parse_string_with_regex(string=Data.value,regex=pathRegex) as regDataFROM glob(globs=split(string=runKeys, sep=&amp;#34;[, \\n]+&amp;#34;),accessor=&amp;#34;reg&amp;#34;)WHERE Data.value# Handle some variations we see in the value:# system32\drivers\XXX.</description></item><item><title>Linux.Memory.Acquisition</title><link>https://docs.velociraptor.app/exchange/artifacts/pages/linuxmemoryacquisition/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/exchange/artifacts/pages/linuxmemoryacquisition/</guid><description>Acquires a full memory image. We download LiME and use it to acquire a full memory image.
NOTE: This artifact usually transfers a lot of data. You should increase the default timeout to allow it to complete. ( Example : 2Gb of memory time takes about 50s )
name:Linux.Memory.Acquisitionauthor:URCA (Corentin Garcia / Emmanuel Mesnard)description:|Acquires a full memory image. We download LiME and use it to acquire a full memory image. NOTE: This artifact usually transfers a lot of data.</description></item><item><title>Linux.Volatility.Create.Profile</title><link>https://docs.velociraptor.app/exchange/artifacts/pages/volatility_profile/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/exchange/artifacts/pages/volatility_profile/</guid><description>This artifact is used to create the profile to the environnements Debian / Ubuntu.
name:Linux.Volatility.Create.Profileauthor:URCA (Corentin Garcia / Emmanuel Mesnard)description:|This artifact is used to create the profile to the environnements Debian / Ubuntu.required_permissions:- EXECVEtools:- name:Volatilityurl:https://github.com/volatilityfoundation/volatility/archive/master.zipparameters:- name:Zipnametype:stringdefault:Ubuntuprecondition:SELECT OS From info() where OS = &amp;#39;linux&amp;#39;sources:- queries:- LET dirtmp = tempdir(remove_last=true)LET vola = SELECT * FROM execve(argv=[&amp;#39;bash&amp;#39;, &amp;#39;-c&amp;#39;, &amp;#39;mv /tmp/master.zip /tmp/volatility-master.zip ; cd /tmp/ ; apt install -y dwarfdump zip unzip ; unzip -o /tmp/volatility-master.</description></item><item><title>OleParser</title><link>https://docs.velociraptor.app/golang/oleparse/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/golang/oleparse/</guid><description/></item><item><title>Regparser</title><link>https://docs.velociraptor.app/golang/regparser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/golang/regparser/</guid><description/></item><item><title>Timetracker</title><link>https://docs.velociraptor.app/golang/timetracker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/golang/timetracker/</guid><description/></item><item><title>Velociraptor</title><link>https://docs.velociraptor.app/golang/velociraptor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/golang/velociraptor/</guid><description/></item><item><title>Vfilter</title><link>https://docs.velociraptor.app/golang/vfilter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/golang/vfilter/</guid><description/></item><item><title>Vtypes</title><link>https://docs.velociraptor.app/golang/vtypes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/golang/vtypes/</guid><description/></item><item><title>Windows.Applications.FTKImager</title><link>https://docs.velociraptor.app/exchange/artifacts/pages/ftkimager/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/exchange/artifacts/pages/ftkimager/</guid><description>Create an E01 Image of the C drive using FTK Imager (Command Line Version)
SourceDriveToImage usually will be 0 (as in \.\PHYSICALDRIVE0) for the C: drive, on a Windows system.
If you intend to image the secondary drive, use, for example, SourceDriveToImage = 1, for \.\PHYSICALDRIVE1
name:Windows.Applications.FTKImagerdescription:|Create an E01 Image of the C drive using FTK Imager (Command Line Version) SourceDriveToImage usually will be 0 (as in \\.\PHYSICALDRIVE0) for the C: drive, on a Windows system.</description></item><item><title>Windows.Detection.PrintNightmare</title><link>https://docs.velociraptor.app/exchange/artifacts/pages/printnightmare/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/exchange/artifacts/pages/printnightmare/</guid><description>This artifact returns any binaries in the Windows/spool/drivers/** folders with an untrusted Authenticode entry.
It can be used to hunt for dll files droped during exploitation of CVE-2021-1675 - PrintNightmare.
To query all attached ntfs drives: check the AllDrives switch.
I have added several filters to uplift search capabilities from the original MFT artifact. Due to the multi-drive features, the MFTPath will output the MFT path of the entry.
Available filters include:</description></item><item><title>Windows.ETW.AMSI</title><link>https://docs.velociraptor.app/exchange/artifacts/pages/amsi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/exchange/artifacts/pages/amsi/</guid><description>This artifact uses the ETW provider: (Microsoft-Antimalware-Scan-Interface - {2A576B87-09A7-520E-C21A-4942F0271D67}
name:Windows.ETW.AMSIdescription:|This artifact uses the ETW provider: (Microsoft-Antimalware-Scan-Interface - {2A576B87-09A7-520E-C21A-4942F0271D67}type:CLIENT_EVENTparameters:- name:IocRegexdescription:&amp;#34;Regex of strings to filter for&amp;#34;default:.- name:WhitelistRegexdescription:&amp;#34;Regex of strings to witelist&amp;#34;- name:AppNameRegexdescription:&amp;#34;Application name Regex to enable filtering on source.&amp;#34;default:.sources:- query:|-- collect a small cache of process information for enrichment LET proc = cache(key=&amp;#39;Pid&amp;#39;, period=600, query={ SELECT Pid, Name, Exe,CommandLine, Username,TokenIsElevated FROM pslist() })-- watch ETW provider and first round data manipulationLET hits = SELECT *,timestamp(epoch=timestamp(string=System.</description></item><item><title>Windows.Monitoring.PrintNightmare</title><link>https://docs.velociraptor.app/exchange/artifacts/pages/printnightmaremonitor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/exchange/artifacts/pages/printnightmaremonitor/</guid><description>This artifact returns ETW PrintService events for potential PrintNightmare activity.
CVE-2021-1675 and CVE-2021-34527
It monitors for DRIVER_ADDED events and enriches with binary information for payload DataFile. Hunt for unexpected drivers with malicious DataFiles.
name:Windows.Monitoring.PrintNightmareauthor:Matt Green - @mgreen27description:|This artifact returns ETW PrintService events for potential PrintNightmare activity. CVE-2021-1675 and CVE-2021-34527 It monitors for DRIVER_ADDED events and enriches with binary information for payload DataFile. Hunt for unexpected drivers with malicious DataFiles. type:CLIENT_EVENTsources:- query:|-- Monitor ETW provider and extract enriched target events LET hits = SELECT System.</description></item><item><title>Windows.Remediation.PrintSpooler</title><link>https://docs.velociraptor.app/exchange/artifacts/pages/printspoolerremediation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/exchange/artifacts/pages/printspoolerremediation/</guid><description>This artifact will enable mitigation of PrintSpooler exploitation used by PrintNightmare - CVE-2021-34527 and CVE-2021-1675.
There are two selectable mitigations:
disabling the print spooler service.
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Spooler\Start = 4 (service disabled).
disable remote registration of the spool service. HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Printers\RegisterSpoolerRemoteRpcEndPoint = 2 (RegisterSpoolerRemoteRpcEndPoint disables).
NOTE: ChangeServiceStartup will set to disable, not stop the printspool service. Its always reccomended to use group policy to deploy these settings.</description></item><item><title>Windows.System.PrinterDriver</title><link>https://docs.velociraptor.app/exchange/artifacts/pages/printerdriver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.velociraptor.app/exchange/artifacts/pages/printerdriver/</guid><description>This artifact will enumerate installed PrintDrivers using the Win32_PrinterDriver wmi class and parse each DriverPath, ConfigFile and DataFile.
Hunt by searching for untrusted binaries or suspicious removed binararies for evidence of previous exploitation.
name:Windows.System.PrinterDriverauthor:Matt Green - @mgreen27description:|This artifact will enumerate installed PrintDrivers using the Win32_PrinterDriver wmi class and parse each DriverPath, ConfigFile and DataFile. Hunt by searching for untrusted binaries or suspicious removed binararies for evidence of previous exploitation. type:CLIENTsources:- query:|LET Win32_PrinterDrivers = SELECT split(string=Name, sep=&amp;#39;,&amp;#39;)[0] as Name, SupportedPlatform, Version, DriverPath, ConfigFile, DataFile FROM wmi(query=&amp;#39;SELECT * FROM Win32_PrinterDriver&amp;#39;,namespace=&amp;#39;root/CIMV2&amp;#39;)SELECT * FROM Win32_PrinterDrivers- name:BinaryCheckquery:|SELECT lowcase(string=Binary) as Binary, array(a1={ SELECT Name FROM Win32_PrinterDrivers WHERE ( DriverPath = Binary OR ConfigFile = Binary OR DataFile = Binary ) }) as DriverNames, hash(path=Binary) as Hash, parse_pe(file=Binary) as PE, authenticode(filename=Binary) as Authenticode FROM chain( a={ SELECT Name, DriverPath as Binary, &amp;#39;DriverPath&amp;#39; as Type FROM Win32_PrinterDrivers }, b={ SELECT Name as DriverName, ConfigFile as Binary, &amp;#39;ConfigFile&amp;#39; as Type FROM Win32_PrinterDrivers }, c={ SELECT Name as DriverName, DataFile as Binary, &amp;#39;DataFile&amp;#39; as Type FROM Win32_PrinterDrivers }) GROUP BY lowcase(string=Binary)</description></item></channel></rss>